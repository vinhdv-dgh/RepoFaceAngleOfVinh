<!DOCTYPE html>
<html>

<head>
    <meta charset="utf-8">
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bulma@0.9.2/css/bulma.min.css">
    <link rel="shortcut icon" href="favicon.ico" />
    <link rel="stylesheet" type="text/css"
        href="https://cdn.jsdelivr.net/npm/@mediapipe/control_utils@0.1/control_utils.css" crossorigin="anonymous">
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils@0.1/camera_utils.js"
        crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/control_utils@0.1/control_utils.js"
        crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils@0.1/drawing_utils.js"
        crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/face_mesh@0.1/face_mesh.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mjyc/opencv.js@1.0.0/opencv.min.js" ></script>
</head>

<body>
    <!-- CONTENTS -->
    <div class="container" style="margin-top: 20px;">

        <div class="columns">

            <!-- WEBCAM INPUT -->
            <div class="column">
                <article class="panel is-info">
                    <p class="panel-heading">
                        Webcam Input
                    </p>
                    <div class="panel-block">
                        <video class="input_video2"></video>
                    </div>
                </article>
            </div>

            <!-- MEDIAPIPE OUTPUT -->
            <div class="column">
                <article class="panel is-info">
                    <p class="panel-heading">
                        Mediapipe Face Mesh
                    </p>
                    <div class="panel-block">
                        <canvas class="output2" width="640px" height="480px"></canvas>
                    </div>
                </article>
            </div>
        </div>

        <div class="loading">
            <div class="spinner"></div>
        </div>
        <div style="visibility: hidden;" class="control2">
        </div>

        <script>
            const video2 = document.getElementsByClassName('input_video2')[0];
            const out2 = document.getElementsByClassName('output2')[0];
            const controlsElement2 = document.getElementsByClassName('control2')[0];
            const canvasCtx = out2.getContext('2d');

            const fpsControl = new FPS();
            const spinner = document.querySelector('.loading');
            spinner.ontransitionend = () => {
                spinner.style.display = 'none';
            };

            function onResultsFaceMesh(results) {
                document.body.classList.add('loaded');
                fpsControl.tick();

                canvasCtx.save();
                canvasCtx.clearRect(0, 0, out2.width, out2.height);
                canvasCtx.drawImage(
                    results.image, 0, 0, out2.width, out2.height);
                const img_w = out2.width;
                const img_h = out2.height;
                const numRows = 6;
                const modelPoints = cv.Mat.zeros(numRows, 3, cv.CV_64FC1);
                // Camera internals
                const size = { width: 640, height: 480 };
                const focalLength = size.width;
                const center = [size.width / 2, size.height / 2];
                const cameraMatrix = cv.matFromArray(3, 3, cv.CV_64FC1, [
                    focalLength,
                    0,
                    center[0],
                    0,
                    focalLength,
                    center[1],
                    0,
                    0,
                    1
                ]);
                // Create Matrixes
                const imagePoints = cv.Mat.zeros(numRows, 2, cv.CV_64FC1);
                const distCoeffs = cv.Mat.zeros(4, 1, cv.CV_64FC1); // Assuming no lens distortion
                const tvec = new cv.Mat({ width: 1, height: 3 }, cv.CV_64FC1);
                const rvec = cv.Mat.zeros(1, 3, cv.CV_64FC1);
                window.beforeunload = () => {
                    imagePoints.delete();
                    distCoeffs.delete();
                    rvec.delete();
                    tvec.delete();
                };
                if (results.multiFaceLandmarks) {
                    let angle = '';
                    for (const landmarks of results.multiFaceLandmarks) {
                        drawConnectors(
                            canvasCtx, landmarks, FACEMESH_TESSELATION,
                            { color: '#C0C0C070', lineWidth: 1 });
                        let index = 0;
                        let nose_2d, nose_3d;
                        
                        let xMin = img_w;
                        let yMin = img_h;
                        let xMax = 0;
                        let yMax = 0;
                        for (let i = 0; i < landmarks.length; i++) {
                            const lm = landmarks[i];
                            // canvasCtx.fillStyle = '#FF0000';
                            // canvasCtx.beginPath();
                            // canvasCtx.arc(lm.x * img_w, lm.y * img_h, 2, 0, 2 * Math.PI);
                            // canvasCtx.fill();

                            // // Gắn chỉ số lên điểm đỏ
                            // canvasCtx.fillStyle = '#00FF00';
                            // canvasCtx.font = '12px Arial';
                            // canvasCtx.fillText(i.toString(), lm.x * img_w, lm.y * img_h);

                            const xlm = lm.x * img_w;
                            const ylm = lm.y * img_h;

                            if (xlm < xMin) xMin = xlm;
                            if (xlm > xMax) xMax = xlm;
                            if (ylm < yMin) yMin = ylm;
                            if (ylm > yMax) yMax = ylm;
                            if (i == 4) {
                                nose_2d = [lm.x * img_w, lm.y * img_h]
                                nose_3d = [lm.x * img_w, lm.y * img_h, lm.z * 3000]
                                imagePoints.data64F[0] = lm.x * img_w;
                                imagePoints.data64F[1] = lm.y * img_h;

                                modelPoints.data64F[0] = lm.x * img_w;
                                modelPoints.data64F[1] = lm.y * img_h;
                                modelPoints.data64F[2] = lm.z;
                            }
                            if (i == 263) {
                                imagePoints.data64F[2] = lm.x * img_w;
                                imagePoints.data64F[3] = lm.y * img_h;

                                modelPoints.data64F[3] = lm.x * img_w;
                                modelPoints.data64F[4] = lm.y * img_h;
                                modelPoints.data64F[5] = lm.z;
                            }

                            if (i == 61) {
                                imagePoints.data64F[4] = lm.x * img_w;
                                imagePoints.data64F[5] = lm.y * img_h;

                                modelPoints.data64F[6] = lm.x * img_w;
                                modelPoints.data64F[7] = lm.y * img_h;
                                modelPoints.data64F[8] = lm.z;

                            }

                            if (i == 291) {
                                imagePoints.data64F[6] = lm.x * img_w;
                                imagePoints.data64F[7] = lm.y * img_h;

                                modelPoints.data64F[9] = lm.x * img_w;
                                modelPoints.data64F[10] = lm.y * img_h;
                                modelPoints.data64F[11] = lm.z;
                            }

                            if (i == 199) {
                                imagePoints.data64F[8] = lm.x * img_w;
                                imagePoints.data64F[9] = lm.y * img_h;

                                modelPoints.data64F[12] = lm.x * img_w;
                                modelPoints.data64F[13] = lm.y * img_h;
                                modelPoints.data64F[14] = lm.z;
                            }

                            if (i == 33) {
                                imagePoints.data64F[10] = lm.x * img_w;
                                imagePoints.data64F[11] = lm.y * img_h;

                                modelPoints.data64F[15] = lm.x * img_w;
                                modelPoints.data64F[16] = lm.y * img_h;
                                modelPoints.data64F[17] = lm.z;
                            }
                        }
                        tvec.data64F[0] = -100;
                        tvec.data64F[1] = 100;
                        tvec.data64F[2] = 1000;
                        const success = cv.solvePnP(
                            modelPoints,
                            imagePoints,
                            cameraMatrix,
                            distCoeffs,
                            rvec,
                            tvec,
                            true
                        );

                        if (!success){
                            return;
                        }

                        const x = rvec.data64F[0] * 360;
                        const y = rvec.data64F[1] * 360;
                        const z = rvec.data64F[2] * 360;

                        if (y < -0.15) {
                            angle = 'left';
                            if (x < -0.15) {
                                angle += ' down';
                            } else if (x > 0.15) {
                                angle += ' up';
                            }
                        } else if (y > 0.15) {
                            angle = 'right';
                            if (x < -0.15) {
                                angle += ' down';
                            } else if (x > 0.15) {
                                angle += ' up';
                            }
                        } else if (x > 0.15) {
                            angle = 'up';
                        } else if (x < - 0.15) {
                            angle = 'down';
                        }
                        else {
                            angle = 'forward';
                        }

                        const centerX = (xMin + xMax) / 2;
                        const centerY = (yMin + yMax) / 2;
                         // Tăng giá trị của bán kính để nới rộng vòng tròn
                        const radius = Math.max(xMax - xMin, yMax - yMin) / 2 * 1.2; // Thay đổi giá trị 1.5 tùy theo mong muốn

                        canvasCtx.beginPath();
                        canvasCtx.arc(centerX, centerY, radius, 0, 2 * Math.PI);
                        canvasCtx.strokeStyle = '#FF0000'; // Màu vòng tròn
                        canvasCtx.lineWidth = 2;
                        canvasCtx.stroke();
                    }

                    // Draw text in the top-left corner
                    canvasCtx.fillStyle = 'rgb(255, 0, 0)';
                    canvasCtx.font = '18px Arial';
                    canvasCtx.fillText(angle, 10, 25);
                    
                }
                canvasCtx.restore();
            }

            const faceMesh = new FaceMesh({
                locateFile: (file) => {
                    return `https://cdn.jsdelivr.net/npm/@mediapipe/face_mesh@0.1/${file}`;
                }
            });
            faceMesh.onResults(onResultsFaceMesh);

            const camera = new Camera(video2, {
                onFrame: async () => {
                    await faceMesh.send({ image: video2 });
                },
                width: 640,
                height: 480
            });
            camera.start();

            new ControlPanel(controlsElement2, {
                selfieMode: true,
                maxNumFaces: 1,
                minDetectionConfidence: 0.5,
                minTrackingConfidence: 0.5
            })
                .add([
                    new StaticText({ title: 'MediaPipe Face Mesh' }),
                    fpsControl,
                    new Toggle({ title: 'Selfie Mode', field: 'selfieMode' }),
                    new Slider({
                        title: 'Max Number of Faces',
                        field: 'maxNumFaces',
                        range: [1, 4],
                        step: 1
                    }),
                    new Slider({
                        title: 'Min Detection Confidence',
                        field: 'minDetectionConfidence',
                        range: [0, 1],
                        step: 0.01
                    }),
                    new Slider({
                        title: 'Min Tracking Confidence',
                        field: 'minTrackingConfidence',
                        range: [0, 1],
                        step: 0.01
                    }),
                ])
                .on(options => {
                    video2.classList.toggle('selfie', options.selfieMode);
                    faceMesh.setOptions(options);
                });
        </script>
</body>

</html>